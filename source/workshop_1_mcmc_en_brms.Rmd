---
title: "Workshop Bayesiaanse statistiek 2023"
subtitle: "1. MCMC, model specificatie met brms en interpretatie van de output"
author: "Raïsa Carmen, Ward Langeraert & Toon Van Daele"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: show
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
# Set up
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE)
opts_knit$set(root.dir = here())
```

```{r packages}
# Packages
library(GLMsData)  # datasets voor GLMs
library(tidyverse) # gegevensverwerking en visualisatie
library(brms)      # fitten van Bayesiaanse modellen
library(bayesplot) # MCMC visualisatie en posterior predictive checks
library(tidybayes) # nabewerking en visualisatie van Bayesiaanse modellen

# Conflicten
conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::lag)
conflicted::conflicts_prefer(brms::ar)
conflicted::conflicts_prefer(brms::dstudent_t)
conflicted::conflicts_prefer(brms::pstudent_t)
conflicted::conflicts_prefer(brms::qstudent_t)
conflicted::conflicts_prefer(brms::rstudent_t)
conflicted::conflict_prefer("rhat", "brms")
```

# Wat is Bayesiaanse statistiek?

Korte herhaling: wat is bayesiaanse statistiek
Prior + likelihood -> posterior
normal/ binomial/ poisson

# Parmeterschatting via MCMC

laat ze zelf een chain runnen (buiten brms?)
Chains, iterations, burn-in -> https://nicercode.github.io/guides/mcmc/
Rhat
Parallel running
Stan
Verschillende regels metropolis-hastings algoritme

# Een model fitten met brms
## Dataset laden en data exploratie

We laden een dataset in over het aantal mierensoorten in New England (USA).
Typ `?ants` in de console voor meer info.

```{r}
# Laad dataset in
data(ants)

# Maak kopie met kolomnamen in kleine letters
ants_df <- ants %>%
  rename(sp_rich = Srich) %>%
  rename_with(tolower)

# Hoe zien de data eruit?
glimpse(ants_df)
```

We hebben een aantal sites (`site`) waar het aantal soorten mieren geteld zijn (`sp_rich`).
Enkele variabelen zijn aanwezig: `habitat`, `latitude` en hoogte (`elevation`).
We bekijken enkele samenvattende statistieken.
In elke site zijn 2 tellingen gedaan: in moeras (`bog`) en in bos (`forest`).

```{r}
summary(ants_df)
```

We visualiseren de data.
Frequentie van het aantal soorten per habitat.

```{r}
ants_df %>%
  ggplot(aes(x = sp_rich)) +
    geom_bar() +
    scale_x_continuous(limits = c(0, NA)) +
    facet_wrap(~habitat)
```

Verdeling van het aantal soorten per habitat.

```{r}
ants_df %>%
  ggplot(aes(y = sp_rich, x = habitat)) +
    geom_boxplot() +
    geom_line(aes(colour = site, group = site), alpha = 0.5) +
    geom_point(aes(colour = site, group = site)) +
    scale_y_continuous(limits = c(0, NA))
```

Relatie tussen het aantal soorten en latitude per habitat.

```{r}
ants_df %>%
  ggplot(aes(y = sp_rich, x = latitude)) +
    geom_point() +
    geom_smooth(method = "loess", formula = "y ~ x", colour = "firebrick") +
    facet_wrap(~habitat)
```

Relatie tussen het aantal soorten en hoogte per habitat.

```{r}
ants_df %>%
  ggplot(aes(y = sp_rich, x = elevation)) +
    geom_point() +
    geom_smooth(method = "loess", formula = "y ~ x", colour = "firebrick") +
    facet_wrap(~habitat)
```

## Een simpel model voor de vergelijking van het aantal soorten tussen habitats
### Model specificatie

We willen een model waarmee we het verschil kunnen onderzoeken in aantal soorten mieren tussen moeras- en boshabitats.
Beschouw de responsvariabele $Y$ het aantal mieren $X_{habitat}$ een dummy variabele die gelijk is aan 0 voor moerassen en 1 voor bossen.
We veronderstellen dat $Y$ een normaal verdeling volgt (dus een lineaire regressie met categorische variabele (= ANOVA))

$$
Y \sim N(\mu, \sigma^2)
$$

met

$$
\mu = \beta_0 + \beta_1X_{habitat}
$$

We moeten dus drie paramters schatten: $\beta_0$, $\beta_1$ en $\sigma$.
Hoe specificeren we dit in **brms**?

Eerst en vooral besluiten we welke MCMC parameters we zullen gebruiken.
Typ `?brm` om te zien wat de standaard instellingen zijn voor deze parameters.
Aangeraden is om meerdere chains te gebruiken (`nchains`) en deze parallel te laten lopen op verschillende cores van je computer (`nparallel`).
Aangezien dat dit een relatief simpel model is, hebben we niet veel iteraties nodig en geen verdunning.

```{r}
# MCMC parameters
nchains <- 3           # aantal chains
niter <- 2000          # aantal iteraties (incl. burn-in, zie volgende)
burnin <- niter / 4    # aantal initiële samples om te verwijderen (= burn-in)
nparallel <- nchains   # aantal cores voor parallel computing
thinning <- 1          # verdunningsfactor (hier 1 = geen verdunning)
```

Het model wordt gefit a.d.h.v. de `brm()` functie.
De syntax is zeer gelijkaardig als functies die in frequentist statistics worden gebruikt zoals `lm()` en `glm()`.

```{r}
# Fit Normaal model
fit_normal1 <- brm(
  formula = sp_rich ~ habitat, # beschrijving van het model
  family = gaussian(),         # we gebruiken de Normale verdeling
  data = ants_df,              # ingeven data
  chains = nchains,            # MCMC parameters
  warmup = burnin, 
  iter = niter,
  cores = nparallel,
  thin = thinning,
  seed = 123)                  # seed voor reproduceerbare uitkomst
```

Voor we de resultaten bekijken, controleren we eerst of het model goed geconvergeerd is.

### MCMC convergentie

https://mc-stan.org/bayesplot/articles/visual-mcmc-diagnostics.html

https://mc-stan.org/bayesplot/articles/plotting-mcmc-draws.html

```{r}
color_scheme_set("mix-blue-red")
```

Wat is een trace plot?

```{r}
mcmc_trace(fit_normal1, pars = c("b_Intercept", "b_habitatForest"))
```

Wat is posterior density?

```{r}
mcmc_dens_overlay(fit_normal1, pars = c("b_Intercept", "b_habitatForest"))
```

Of eenvoudiger:

```{r}
plot(fit_normal1)
```


Wat is Rhat?

```{r}
rhats_fit_normal1 <- rhat(fit_normal1)[c("b_Intercept", "b_habitatForest")]
mcmc_rhat(rhats_fit_normal1) + yaxis_text(hjust = 1)
```

+ effective sample size
...

Correlatie?...

```{r}
mcmc_pairs(fit_normal1, pars = c("b_Intercept", "b_habitatForest"),
           off_diag_args = list(size = 1.5))
```

### Model fit

https://mc-stan.org/bayesplot/articles/graphical-ppcs.html

Uitleg posterior predictive check.

```{r}
pp_check(fit_normal1, type = "dens_overlay_grouped", ndraws = 100, 
         group = "habitat")
```


## Een simpel model voor de vergelijking van het aantal soorten tussen habitats
### Model specificatie

Eerst en vooral specificeren we de MCMC parameters ...

```{r}
# MCMC parameters
nchains <- 3           # aantal chains
niter <- 2000          # aantal iteraties (incl. burn-in, zie volgende)
burnin <- niter / 4    # aantal initiële samples om te verwijderen (= burn-in)
nparallel <- nchains   # aantal cores voor parallel computing
thinning <- 1          # verdunningsfactor (hier 1 =geen verdunning)
```

$$
Y \sim Pois(\beta_0 + \beta_1X_{habitat})\\
\Rightarrow \ln(E(Y)) = \beta_0 + \beta_1X_{habitat}
$$

```{r}
# Fit Poisson model
fit_poisson1 <- brm(formula = sp_rich ~ habitat,
            data = ants_df,
            family = poisson(),
            chains = nchains, 
            warmup = burnin, 
            iter = niter,
            cores = nparallel,
            thin = thinning,
            seed = 123)
```


### MCMC convergentie

https://mc-stan.org/bayesplot/articles/visual-mcmc-diagnostics.html

https://mc-stan.org/bayesplot/articles/plotting-mcmc-draws.html

```{r}
color_scheme_set("mix-blue-red")
```

Wat is een trace plot?

```{r}
mcmc_trace(fit_poisson1, pars = c("b_Intercept", "b_habitatForest"))
```

Wat is posterior density?

```{r}
mcmc_dens_overlay(fit_poisson1, pars = c("b_Intercept", "b_habitatForest"))
```

Of eenvoudiger:

```{r}
plot(fit_poisson1)
```


Wat is Rhat?

```{r}
rhats_fit_poisson1 <- rhat(fit_poisson1)[c("b_Intercept", "b_habitatForest")]
mcmc_rhat(rhats_fit_poisson1) + yaxis_text(hjust = 1)
```

+ effective sample size
...

Correlatie?...

```{r}
mcmc_pairs(fit_poisson1, pars = c("b_Intercept", "b_habitatForest"),
           off_diag_args = list(size = 1.5))
```

### Model fit

https://mc-stan.org/bayesplot/articles/graphical-ppcs.html

Uitleg posterior predictive check.

```{r}
pp_check(fit_poisson1, type = "dens_overlay_grouped", ndraws = 100, 
         group = "habitat")
```

# Vergelijken van modellen
## Model specificatie

```{r}
fit_poisson2 <- brm(formula = sp_rich ~ habitat + (1|site),
            data = ants_df,
            family = poisson(),
            chains = nchains, 
            warmup = burnin, 
            iter = niter,
            cores = nparallel,
            thin = thinning,
            seed = 123)
```

## MCMC convergentie

```{r}
plot(fit_poisson2)
```

```{r}
vars <- c("b_Intercept", "b_habitatForest", "sd_site__Intercept")
rhats_fit_poisson2 <- rhat(fit_poisson2)[vars]
mcmc_rhat(rhats_fit_poisson2) + yaxis_text(hjust = 1)
```

## Model fit

```{r}
pp_check(fit_poisson2, type = "dens_overlay_grouped", ndraws = 100, 
         group = "habitat")
```

## Model selectie

https://mc-stan.org/loo/articles/online-only/faq.html

```{r}
# Leave-one-out cross-validation
fit_poisson1 <- add_criterion(fit_poisson1, criterion = "loo")
fit_poisson2 <- add_criterion(fit_poisson2, criterion = "loo")

# Maak vergelijking
comp <- loo_compare(fit_poisson1, fit_poisson2, criterion = "loo")
print(comp, simplify = FALSE, digits = 3)
```

Vergelijking met onzekerheid:

```{r}
comp %>%
  as.data.frame() %>%
  select(elpd_diff, se_diff) %>%
  mutate(ll_diff = elpd_diff  + qnorm(0.025) * se_diff,
         ul_diff = elpd_diff  + qnorm(0.975) * se_diff)
```

# Resultaten finale model

https://mjskay.github.io/tidybayes/articles/tidy-brms.html

```{r}
fit_poisson2 %>%
  gather_draws(b_Intercept, b_habitatForest, ndraws = 1000, seed = 123) %>%
  group_by(.variable) %>%
  summarise(min = min(.value),
            q_05 = quantile(.value, probs = 0.05),
            gemiddelde = mean(.value),
            mediaan = median(.value),
            q_95 = quantile(.value, probs = 0.95),
            max = max(.value))
```

Handige functies zijn ook `median_qi()`, `mean_qi()` ...  na `gather_draws()` in plaats van `group_by()` en `summarise()`.

We zouden graag het geschatte aantal soorten visualiseren per habitattype.
Het gemiddeld aantal soorten in moerassen volgens ons model is $\exp(\beta_0)$ en in bossen $\exp(\beta_0+\beta_1)$.

```{r}
plot_df <- fit_poisson2 %>%
  spread_draws(b_Intercept, b_habitatForest, ndraws = 1000, seed = 123) %>%
  mutate(bog = exp(b_Intercept),
         forest = exp(b_Intercept + b_habitatForest))
```

We tonen ook de posterior mediaan en 60 en 90 % credible interval.

```{r}
plot_df %>%
  pivot_longer(cols = c("bog", "forest"), names_to = "habitat", 
               values_to = "sp_rich") %>%
  ggplot(aes(y = sp_rich, x = habitat)) +
    stat_eye(point_interval = "median_qi", .width = c(0.6, 0.9)) +
    scale_y_continuous(limits = c(0, NA))
```

We zien een duidelijk verschil in aantal soorten tussen beide habitats.
Is er een significant verschil tussen het aantal soorten in moerassen en bossen?
We testen de hypothese

$$
\exp(\beta_0) = \exp(\beta_0+\beta_1)\\
\Rightarrow \beta_0 = \beta_0 + \beta_1\\
\Rightarrow \beta_1 = 0\\
$$

```{r}
hyp <- hypothesis(fit_poisson2, "habitatForest = 0", alpha = 0.05)
hyp
```

```{r}
plot(hyp)
```

We sorteren de random effecten van de sites.

```{r}
# Get mean of sd of random effects 
sd_mean <- fit_poisson2 %>%
  spread_draws(sd_site__Intercept, ndraws = 1000, seed = 123) %>%
  summarise(mean_sd = mean(sd_site__Intercept)) %>%
  pull()

# Get random effects and plot
fit_poisson2 %>%
  spread_draws(r_site[site,], ndraws = 1000, seed = 123) %>%
  ungroup() %>%
  mutate(site = reorder(site, r_site)) %>%
  ggplot(aes(x = r_site, y = site)) +
    geom_vline(xintercept = 0, color = "darkgrey", linewidth = 1) +
    geom_vline(xintercept = c(sd_mean * qnorm(0.025), sd_mean * qnorm(0.975)),
               color = "darkgrey", linetype = 2) +
    stat_halfeye(point_interval = "median_qi", .width = 0.9, size = 2/3,
                 fill = "cornflowerblue")
```
