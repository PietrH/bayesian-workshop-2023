---
title: "Workshop Bayesiaanse statistiek 2023"
subtitle: "1. MCMC, model specificatie met brms en interpretatie van de output"
author: "Raïsa Carmen, Ward Langeraert & Toon Van Daele"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
# Set up
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE)
opts_knit$set(root.dir = here())
```

```{r packages}
# Packages
library(GLMsData)  # datasets voor GLMs
library(tidyverse) # gegevensverwerking en visualisatie
library(brms)      # fitten van Bayesiaanse modellen
library(bayesplot) # MCMC visualisatie en posterior predictive checks
library(tidybayes) # nabewerking en visualisatie van Bayesiaanse modellen

# Conflicten
conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::lag)
conflicted::conflicts_prefer(brms::ar)
conflicted::conflicts_prefer(brms::dstudent_t)
conflicted::conflicts_prefer(brms::pstudent_t)
conflicted::conflicts_prefer(brms::qstudent_t)
conflicted::conflicts_prefer(brms::rstudent_t)
conflicted::conflict_prefer("rhat", "brms")
```

# Theoretische achtergrond

## Wat is Bayesiaanse statistiek?

### Statistische inferentie

https://benlambertdotcom.files.wordpress.com/2019/03/bayesian-course-1-short.pdf

(Zie ook [infomoment 24/10/2023](https://drive.google.com/drive/folders/1MIWu8-LnhTUnKKAchjI7FEmaJ8TN_1mb))
Prior + likelihood -> posterior
normal/ binomial/ poisson

## Parameterschatting in Bayesiaanse statistiek

laat ze zelf een chain runnen (buiten brms?)
Chains, iterations, burn-in -> https://nicercode.github.io/guides/mcmc/
Rhat
Parallel running
Stan
Verschillende regels metropolis-hastings algoritme

# Een model fitten in brms
## Dataset laden en data exploratie

We laden een dataset in van het aantal mierensoorten in New England (USA).
Typ `?ants` in de console voor meer info.

```{r}
# Laad dataset in
data(ants)

# Maak kopie met kolomnamen in kleine letter
ants_df <- ants %>%
  rename(sp_rich = Srich) %>%
  rename_with(tolower)

# Hoe zien de data eruit?
glimpse(ants_df)
```

Enkele samenvattende statistieken:

```{r}
summary(ants_df)
```

We visualiseren de data.

```{r}
ants_df %>%
  ggplot(aes(x = sp_rich)) +
    geom_bar() +
    scale_x_continuous(limits = c(0, NA)) +
    facet_wrap(~habitat)
```

```{r}
ants_df %>%
  ggplot(aes(y = sp_rich, x = habitat)) +
    geom_boxplot() +
    scale_y_continuous(limits = c(0, NA))
```

```{r}
ants_df %>%
  ggplot(aes(y = sp_rich, x = latitude)) +
    geom_point() +
    geom_smooth(method = "loess", formula = "y ~ x", colour = "firebrick") +
    facet_wrap(~habitat)
```

```{r}
ants_df %>%
  ggplot(aes(y = sp_rich, x = elevation)) +
    geom_point() +
    geom_smooth(method = "loess", formula = "y ~ x", colour = "firebrick") +
    facet_wrap(~habitat)
```


## Een eerste simpel model
### Model specificatie

Eerst en vooral specificeren we de MCMC parameters ...

```{r}
# MCMC parameters
nchains <- 3           # aantal chains
niter <- 2000          # aantal iteraties (incl. burn-in, zie volgende)
burnin <- niter / 4    # aantal initiële samples om te verwijderen (= burn-in)
nparallel <- nchains   # aantal cores voor parallel computing
thinning <- 1          # verdunningsfactor (hier 1 =geen verdunning)
```

$$
Y \sim Pois(\beta_0 + \beta_1X_{habitat})\\
\Rightarrow \ln(E(Y)) = \beta_0 + \beta_1X_{habitat}
$$

```{r}
# Fit Poisson model
fit1 <- brm(formula = bf(sp_rich ~ habitat),
            data = ants_df,
            family = poisson(),
            chains = nchains, 
            warmup = burnin, 
            iter = niter,
            cores = nparallel,
            thin = thinning,
            seed = 123)
```


### MCMC convergentie

https://mc-stan.org/bayesplot/articles/visual-mcmc-diagnostics.html

https://mc-stan.org/bayesplot/articles/plotting-mcmc-draws.html

```{r}
color_scheme_set("mix-blue-red")
```

Wat is een trace plot?

```{r}
mcmc_trace(fit1, pars = c("b_Intercept", "b_habitatForest"))
```

Wat is posterior density?

```{r}
mcmc_dens_overlay(fit1, pars = c("b_Intercept", "b_habitatForest"))
```

Of eenvoudiger:

```{r}
plot(fit1)
```


Wat is Rhat?

```{r}
rhats_fit1 <- rhat(fit1)[c("b_Intercept", "b_habitatForest")]
mcmc_rhat(rhats_fit1) + yaxis_text(hjust = 1)
```

+ effective sample size
...

Correlatie?...

```{r}
mcmc_pairs(fit1, pars = c("b_Intercept", "b_habitatForest"),
           off_diag_args = list(size = 1.5))
```

### Model fit

https://mc-stan.org/bayesplot/articles/graphical-ppcs.html

Uitleg posterior predictive check.

```{r}
pp_check(fit1, type = "dens_overlay_grouped", ndraws = 100, 
         group = "habitat")
```

# Vergelijken van modellen
## Model specificatie

```{r}
fit2 <- brm(formula = bf(sp_rich ~ habitat + (1|site)),
            data = ants_df,
            family = poisson(),
            chains = nchains, 
            warmup = burnin, 
            iter = niter,
            cores = nparallel,
            thin = thinning,
            seed = 123)
```

## MCMC convergentie

```{r}
plot(fit2)
```

```{r}
vars <- c("b_Intercept", "b_habitatForest", "sd_site__Intercept")
rhats_fit2 <- rhat(fit2)[vars]
mcmc_rhat(rhats_fit2) + yaxis_text(hjust = 1)
```

## Model fit

```{r}
pp_check(fit2, type = "dens_overlay_grouped", ndraws = 100, 
         group = "habitat")
```

## Model selectie

https://mc-stan.org/loo/articles/online-only/faq.html

```{r}
# Leave-one-out cross-validation
fit1 <- add_criterion(fit1, criterion = "loo")
fit2 <- add_criterion(fit2, criterion = "loo")

# Maak vergelijking
comp <- loo_compare(fit1, fit2, criterion = "loo")
print(comp, simplify = FALSE, digits = 3)
```

Vergelijking met onzekerheid:

```{r}
comp %>%
  as.data.frame() %>%
  select(elpd_diff, se_diff) %>%
  mutate(ll_diff = elpd_diff  + qnorm(0.025) * se_diff,
         ul_diff = elpd_diff  + qnorm(0.975) * se_diff)
```

# Resultaten finale model

https://mjskay.github.io/tidybayes/articles/tidy-brms.html

```{r}
fit2 %>%
  gather_draws(b_Intercept, b_habitatForest, ndraws = 1000, seed = 123) %>%
  group_by(.variable) %>%
  summarise(min = min(.value),
            q_05 = quantile(.value, probs = 0.05),
            gemiddelde = mean(.value),
            mediaan = median(.value),
            q_95 = quantile(.value, probs = 0.95),
            max = max(.value))
```

Handige functies zijn ook `median_qi()`, `mean_qi()` ...  na `gather_draws()` in plaats van `group_by()` en `summarise()`.

We zouden graag het geschatte aantal soorten visualiseren per habitattype.
Het gemiddeld aantal soorten in moerassen volgens ons model is $\exp(\beta_0)$ en in bossen $\exp(\beta_0+\beta_1)$.

```{r}
plot_df <- fit2 %>%
  spread_draws(b_Intercept, b_habitatForest, ndraws = 1000, seed = 123) %>%
  mutate(bog = exp(b_Intercept),
         forest = exp(b_Intercept + b_habitatForest))
```

We tonen ook de posterior mediaan en 60 en 90 % credible interval.

```{r}
plot_df %>%
  pivot_longer(cols = c("bog", "forest"), names_to = "habitat", 
               values_to = "sp_rich") %>%
  ggplot(aes(y = sp_rich, x = habitat)) +
    stat_eye(point_interval = "median_qi", .width = c(0.6, 0.9)) +
    scale_y_continuous(limits = c(0, NA))
```

We zien een duidelijk verschil in aantal soorten tussen beide habitats.
Is er een significant verschil tussen het aantal soorten in moerassen en bossen?
We testen de hypothese

$$
\exp(\beta_0) = \exp(\beta_0+\beta_1)\\
\Rightarrow \beta_0 = \beta_0 + \beta_1\\
\Rightarrow \beta_1 = 0\\
$$

```{r}
hyp <- hypothesis(fit2, "habitatForest = 0", alpha = 0.05)
hyp
```

```{r}
plot(hyp)
```

We sorteren de random effecten van de sites.

```{r}
# Get mean of sd of random effects 
sd_mean <- fit2 %>%
  spread_draws(sd_site__Intercept, ndraws = 1000, seed = 123) %>%
  summarise(mean_sd = mean(sd_site__Intercept)) %>%
  pull()

# Get random effects and plot
fit2 %>%
  spread_draws(r_site[site,], ndraws = 1000, seed = 123) %>%
  ungroup() %>%
  mutate(site = reorder(site, r_site)) %>%
  ggplot(aes(x = r_site, y = site)) +
    geom_vline(xintercept = 0, color = "darkgrey", linewidth = 1) +
    geom_vline(xintercept = c(sd_mean * qnorm(0.025), sd_mean * qnorm(0.975)),
               color = "darkgrey", linetype = 2) +
    stat_halfeye(point_interval = "median_qi", .width = 0.9, size = 2/3,
                 fill = "cornflowerblue")
```
